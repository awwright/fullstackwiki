<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:w="tag:fullstack.wiki,2018:ns/">
	<head>
		<meta charset="UTF-8" />
		<title>ECMAScript Libraries</title>
		<meta name="description" content="" />
		<link rel="up" href="index.html"/>
	</head>
	<body>
		<main id="main-content" vocab="tag:fullstack.wiki,2018:ns/" typeof="HTTP-Header">
			<h1>ECMAScript Libraries</h1>
			<p>This describes how to package and distribute ECMAScript (JavaScript) libraries. This does not cover applications, which do not need to be included as part of another application, although the package may contain utility executables for development use.</p>
			<p>Libaries are typically distrbuted in a bundle of files called a <i>package</i>, which may contain the executable code, as well as development utilities, tests, and documentation.</p>

			<h2>Revision control</h2>
			<p>The package should be revision controlled, Git is highly preferred.</p>

			<h2>README</h2>
			<p>The package should contain a README with the following sections:</p>
			<ol>
				<li>Summary</li>
				<li>Example</li>
				<li>Documentation or link to documentation</li>
				<li>Index of files in the repository</li>
			</ol>

			<h2>LICENSE</h2>
			<p>For legal reasons in most every legal jurisdiction that uses computers, the copyright owners must give permission for other people to use the package. This should be done with a LICENSE file in the repository.</p>

			<h2>index.js</h2>
			<p>The library should have an exposed interface at an <code>index.js</code> file. This file <i>indexes</i> the objects available for applications and other libaries to use.</p>

			<h3>Package version</h3>
			<p>It should not be necessary to expose the package version to the application in an exported property.</p>
			<p>In the event this is really necessary, make this a build step; write the current git tag (using <code>git describe</code>) to a file, which is imported.</p>

			<h2>Package metadata</h2>
			<p>Consumers of the library will typically go through a package repository that keeps track of releases and an ecosystem of package names.</p>
			<p>For npm, use <code>package.json</code>, or a <code>package.yaml</code> file that's built into JSON at package-time.</p>


			<h2>Tests</h2>
			<p>The package should have. Except as needed to verify truly exceptional conditions that cannot be otherwise tested (network errors, etc), tests should test the public-facing interface at <code>index.js</code>.</p>
			<p>Tests should cover common failure modes, including network failure.</p>

			<h2>Build products</h2>
			<p>With certain exceptions, do not check build products into source control. List build products in <code>.gitignore</code> and other files, so that they don't get checked in.</p>
			<p>Exceptions include:</p>
			<ul>
				<li>Products that must be generated by hand by particular individuals. For example, exporting a Photoshop file into a lossless png.</li>
				<li>Source files for historical reference.</li>
				<li>Build products that require additional hand-modification, for example, autogenerated lexer code. This should be automated if at all possible, for example, with a patch file.</li>
				<li>Files that benefit developers and reading the repository for the first time. For example, an index of files, or a README.md generated from other files.</li>
				<li>Project dependencies without a viable alternative for distribution. For example, some test suites.</li>
			</ul>
			<p>Even in most of these cases, consider placing the files under an <code>archive/</code> directory, or using git submodules.</p>
			<p>If a platform requires build products be checked into source control, consider having a branch just for this purpose, e.g. <code>master-build</code> that tracks the current <code>master</code> branch. For targeting different platforms, create multiple such branches (e.g. <code>master-build-nodejs</code>, <code>master-build-cjs</code>, etc).</p>

			<h2>Coverage</h2>
			<p>Using a code coverage tool can help ensure that your tests exercise most all the functionality of your application.</p>
			<p>Tests should call every function in every interface. Assertions need not be covered (for example, testing arguments, or sanity checks), but still might be warrented.</p>

			<h2>Analysis and style checking</h2>
			<p>Packages should use a small variety of style checking tools.</p>
			<p>If you don't have a linter or style guide, then it would be unreasonable rejecting pull requests for bad style alone.</p>

			<h3>.editorconfig</h3>
			<p>Use a <code>.editorconfig</code> file to specify text expectations, including indentation, line endings, and character set.</p>

			<h3>eslint</h3>
			<p>For enforcing code style and testing for common bugs, use ESLint. Keep a <code>.eslintrc.js</code> file around.</p>

			<h2>Credentials</h2>
			<p>Do not store credentials in revision control. Write a test to ensure that example configuration files do not have anything looking like real authentication credentials.</p>
			<p>Tests and development should be possible in offline use. Have a script that configures a completely local development environment for offline use, and keep a test that ensures this script works.</p>
			<p>For shared development databases, provide a link to configuration files that can be downloaded.</p>

			<h2>Continuous integration</h2>
			<p>Use a CI tool to automatically run tests for commits, this can help ensure that pull requests pass tests, for example.</p>
			<p>Do not include credentials, and avoid including data that is specific to a particular user, Git repository (this makes forks difficult, and in turn makes development difficult).</p>
		</main>
	</body>
</html>
