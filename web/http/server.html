<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:w="http://fullstack.wiki/ns/">
	<head>
		<meta charset="UTF-8" />
		<title>HTTP Servers</title>
		<meta name="description" content="Accepting requests from a client and generating a response" />
		<link rel="up" href="index.html" />
		<link rel="stylesheet" href="/style/highlight.js/solarized-light.css" />
	</head>
	<body>
		<main>
			<h1>HTTP Servers</h1>
			<p>This document describes how to implement an HTTP server, from an incoming client request to closing the response.</p>
			<p>Gateways and proxies are described separately, but must follow the behavior here nonetheless, as well as the behavior for clients.</p>

			<h2>Listening for Requests</h2>
			<p>There are multiple ways to listen for HTTP requests, and you may wish to implement more than one of them.</p>
			<p>HTTP is primarially defined in the concrete message syntax, shared by HTTP/1.x and email. HTTP servers should typically always listen on HTTP/1.x (HTTP/1.x refers to both HTTP/1.1 and HTTP/1.0).</p>
			<p>HTTP/1.x by default listens on TCP port 80, and HTTP over TLS on port 443. HTTP also provides alternate ports 8008 and 8080, which is useful for origin servers behind a gateway/firewall, if a unix socket cannot be used.</p>
			<!-- Implement RFC7230 6.1. Connection - TODO: describe some of the attacks and mitigations -->
			<p>Servers are expected to be robust against denial-of-service attacks.</p>
			<!-- TODO: cover other HTTP versions and compatible protocols -->

			<h2>Status codes and emitting errors</h2>
			<p>Some operations below speak of emitting an error, or emitting a status code. This means the response to that request will be a status code (4xx or 5xx if an error), generating a document describing the error (if allowed), and further handling of the request will end (except as necessary to unlock and clean up resources, etc).</p>

			<h2>Accepting Requests (HTTP/1.x)</h2>
			<h3>Parse incoming request headers</h3>
			<p>Except for the simplest of embedded routers, most implementations will need to parse all of the request headers and buffer them in memory, since headers may be specified in any order.</p>
			<p>While HTTP does not specify any specific limits on headers, but servers may.</p>
			<p>Servers receiving a header field, or number of header fields, longer than it is able to handle, should send an appropriate error:</p>
			<!-- Pull some sensible values from Apache HTTPD: http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestline -->
			<!-- Implements RFC6585, RFC7231 -->
			<dl>
				<dt>414 (URI Too Long)</dt><dd>When the request-URI is very long (this length is 8190 in Apache HTTPD)</dd>
				<dt>431 (Request Header Fields Too Large)</dt><dd>When there's a header that's too long, or too many headers. Send this when a header name is longer than the longest known header, when the value is very long (8190 bytes in Apache HTTPD), or when there's too many headers (100 count in Apache HTTPD)</dd>
				<dt>400 (Client Error)</dt><dd>For other cases</dd>
			</dl>

			<h3>Determine incoming HTTP version</h3>
			<p>The first line of the HTTP request will contain the method, resource, and HTTP version. The first course of action is determine the HTTP version the client is using. The line will usually look something like this:</p>
			<pre type="abnf" w:space="indent">
				request-line  = method SP request-target SP HTTP-version CRLF
				HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
				HTTP-name     = %x48.54.54.50 ; "HTTP", case-sensitive
			</pre>
			<p>The HTTP version will be the text after the second space, until the first CR in the CRLF sequence. It should be exactly 8 bytes.</p>
			<pre type="message/http" w:space="indent">
				GET /where?q=now HTTP/1.1
				Host: www.example.org
			</pre>
			<p>If the HTTP-version is not <code>HTTP/1.x</code>, where <code>x</code> is some digit, then return <code>505 (HTTP Version Not Supported)</code>.</p>
			<!-- https://httpwg.org/specs/rfc7230.html#http.version -->

			<h3>Validate Host header</h3>
			<!-- Implements RFC7230 section 5.4 -->
			<p>HTTP/1.1 clients MUST send a Host header, even with the absolute-form or with a request URI with no authority.</p>
			<p>If the request lacks a Host header, or has more than one Host header, return status 400 (Bad Request).</p>

			<h3>Validate Expect header</h3>
			<p>The "Expect" header enumerates the features the client expects the endpoint to implement in order to be able to correctly parse a request or response.</p>
			<p>If the header is set, and is something besides <code>100-continue</code> (case-insensitive), emit 417 (Expectation Failed).</p>
			<p>If the value is "100-continue", the server will need to emit a 100 (Continue) header before the client begins uploading its request-body (implemented below)</p>

			<h3>Compute effective request URI</h3>
			<p>Two lines are used to form the effective Request URI: the request-line (the first line in the request), and the Host header.</p>
			<p>HTTP allows requests with an absolute-form URI in the request-line, however this is not supported by very many servers, and is typically only used for requests to proxies.</p>
			<p>Most requests will be made with the origin-form:</p>
			<pre type="abnf" w:space="indent">
				request-target = origin-form
					/ absolute-form
					/ authority-form
					/ asterisk-form
				origin-form    = absolute-path [ "?" query ]
			</pre>
			<p>Servers must support all these forms, and can be parsed as follows:</p>
			<ol>
				<li>If the first character is the slash <code>/</code>, parse as origin-form.</li>
				<li>If the string contains a slash (not as the first character), parse as absolute-form.</li>
				<li>If the string is the single character asterisk <code>*</code>, parse as asterisk-form.</li>
				<li>Attempt to parse as authority-form.</li>
				<li>Otherwise, emit an error.</li>
			</ol>
			<p>For example:</p>
			<pre type="message/http" w:space="indent">
				GET /where?q=now HTTP/1.1
				Host: www.example.org
			</pre>
			<h4>From origin-form</h4>
			<p>To reconstruct from origin-form, three pieces of data are required: the scheme, the authority, and the path.</p>
			<p>The path must be configured or detected based on configuration. Ideally HTTP requests would always come in from <code>http:</code>. But this is not necessarially the case. First, it is technically possible for an HTTP server to respond to requests for any URI, for example a uuid. Second, HTTP is currently defined over two URI schemes, <code>http:</code> and <code>https:</code>, the latter of which is defined to be transported over TLS.</p>
			<p>The server must be configured to specify which schemes it is reachable by, and how to detect which scheme it was reached over. This is typically straightforward.</p>
			<p>The host is provided in the Host header. HTTP/1.0 does not require the Host header, in which case the server may either opt to detect the Host, or return an error.</p>
			<p>After validating, can be constructed from the template <code>{scheme}:{slash}{authority}{path}</code>, where:</p>
			<dl class="inline">
				<dt>{scheme}</dt><dd>the detected scheme</dd>
				<!--
					RFC7230 section 5.5 says the scheme and authority are concatenated with `://`,
					but according to section 5.4 if the URI has no authority component (and thus no `//`),
					the Host header is blank.
				-->
				<dt>{slash}</dt><dd>two slashes <code>//</code> if <code>authority</code> is non-empty, or an empty string otherwise</dd>
				<dt>{authority}</dt><dd>value from the <code>Host</code> header</dd>
				<dt>{path}</dt><dd>value from the request-URI</dd>
			</dl>
			<!-- TODO: reference TLS -->

			<h4>From absolute-form</h4>
			<p>The request-URI is what is found on the request-line.</p>
			<p>Verify the syntax is a valid URI, and return 400 (Client Error) if not.</p>
			<p>Verify the host and port (if any) components match the Host header, and return 400 (Client Error) if not.</p>

			<h2>Read request body metadata</h2>
			<h3>Content-Language</h3>
			<p>HTTP allows the sender to identify the primary language of the entity body (request body or response body) using the <code>Content-Language</code> header.</p>

			<h3>Determine Content-Type</h3>
			<p>The <code>Content-Type</code> header determines which media type will be used to decode the entity-body.</p>
			<p>Generally for every media type, there is a single specification that specifies how to parse and use the document.</p>

			<h2>Process payload contents</h2>
			<h3>If there's a request-body, decode Content-Encoding</h3>
			<blockquote><p>If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.</p></blockquote>

			<h3>Handle 100-continue</h3>
			<p>If the client set the <code>100-continue</code> flag, that means it has a large upload it wants to send, but it will wait for confirmation from the server before uploading its request-body.</p>

			<h2>Overview table</h2>
			<h3>Referenced specifications</h3>
			<ul class="inline">
				<li><a href="https://httpwg.org/specs/rfc7230.html">RFC 7230: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a></li>
				<li><a href="https://httpwg.org/specs/rfc7230.html">RFC 7230: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a></li>
				<li><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANA: Service Name and Transport Protocol Port Number Registry</a></li>
			</ul>
		</main>
	</body>
</html>
