<!DOCTYPE html>
<html lang="en" dir="ltr" xmlns="http://www.w3.org/1999/xhtml" xmlns:w="http://fullstack.wiki/ns/">
	<head>
		<meta charset="UTF-8" />
		<title>HTTP Servers</title>
		<meta name="description" content="Accepting requests from a client and generating a response" />
		<link rel="up" href="index.html" />
		<link rel="stylesheet" href="/style/highlight.js/solarized-light.css" />
	</head>
	<body>
		<main>
			<h1>HTTP Servers</h1>
			<p>This document describes how to implement an HTTP server, from an incoming client request to closing the response.</p>
			<p>Gateways and proxies are described separately, but must follow the behavior here nonetheless, as well as the behavior for clients.</p>

			<h2>Listening for Requests</h2>
			<p>There are multiple ways to listen for HTTP requests, and you may wish to implement more than one of them.</p>
			<p>HTTP is primarially defined in the concrete message syntax, shared by HTTP/1.x and email. HTTP servers should typically always listen on HTTP/1.x (HTTP/1.x refers to both HTTP/1.1 and HTTP/1.0).</p>
			<p>HTTP/1.x by default listens on TCP port 80, and HTTP over TLS on port 443. HTTP also provides alternate ports 8008 and 8080, which is useful for origin servers behind a gateway/firewall, if a unix socket cannot be used.</p>
			<!-- Implements RFC7230 6.1. Connection - TODO: describe some of the attacks and mitigations -->
			<p>Servers are expected to be robust against denial-of-service attacks.</p>
			<p>An incoming connection might not necessarially be the one making the requests, and a connection might send requests from many different user agents.</p>
			<!-- TODO: cover other HTTP versions and compatible protocols -->

			<h2>Status codes and emitting errors</h2>
			<p>Some operations below speak of emitting an error, or emitting a status code. This means the response to that request will be a status code (4xx or 5xx if an error), generating a document describing the error (if allowed), and further handling of the request will end (except as necessary to unlock and clean up resources, etc).</p>

			<h2>Parse incoming request headers (HTTP/1.x)</h2>
			<p>Except for the simplest of embedded routers, most implementations will need to parse all of the request headers and buffer them in memory, since headers may be specified in any order.</p>

			<h3>Header length limits</h3>
			<p>While HTTP does not specify any specific limits on headers, servers may emit an error if a request has exceeded resource limits:</p>
			<!-- Pull some sensible values from Apache HTTPD: http://httpd.apache.org/docs/2.2/mod/core.html#limitrequestline -->
			<!-- Implements RFC6585, RFC7231 -->
			<dl>
				<dt>414 (URI Too Long)</dt><dd>When the request-URI is very long (this length is 8190 in Apache HTTPD)</dd>
				<dt>431 (Request Header Fields Too Large)</dt><dd>When there's a header that's too long, or too many headers. Send this when a header name is very long (the longest known header plus some amount to accomidate new headers without interrupting client requests, about 100 bytes), when the value is very long (8190 bytes in Apache HTTPD), or when there's too many headers (100 count in Apache HTTPD)</dd>
			</dl>
			<p>If the server statically knows all of the resources it needs to process, the request URI limit should be at least as large as the largest URI.</p>
			<p>Resource limits for the request-body are treated below.</p>

			<h3>HTTP version</h3>
			<p>The HTTP version is specified on the first line, the request-line, for example:</p>
			<pre type="message/http" w:space="indent">
				GET /where?q=now HTTP/1.1
			</pre>
			<p>If the HTTP-version is not <code>HTTP/1.x</code>, where <code>x</code> is some digit, then return <code>505 (HTTP Version Not Supported)</code>.</p>
			<!-- https://httpwg.org/specs/rfc7230.html#http.version -->

			<h2>Consume Connection headers</h2>
			<h3>Connect header</h3>
			<!-- Implements RFC7231 5.1.2. Max-Forwards -->
			<p>The <code>Connection</code> header specifies hop-by-hop information about the connection that must be consumed (removed) before forwarding. This means that received Connection headers are from the previous node, not from the user-agent.</p>
			<p>The Connection header may also list header names. Any request headers that are listed in Connection are connection headers, and are not to be forwarded.</p>

			<h2>Verify client requirements</h2>
			<h3>Validate Expect header</h3>
			<!-- Implements RFC7231 5.1.1. Expect -->
			<p>The "Expect" header enumerates the features the client expects the endpoint to implement in order to be able to correctly parse a request or response.</p>
			<p>If the header is set, and is something besides <code>100-continue</code> (case-insensitive), emit 417 (Expectation Failed).</p>
			<p>If the value is "100-continue", the server will need to emit a 100 (Continue) header before the client begins uploading its request-body (implemented below)</p>

			<h3>Validate Host header</h3>
			<!-- Implements RFC7230 5.4. -->
			<p>HTTP/1.1 clients MUST send a Host header, even with the absolute-form or with a request URI with no authority.</p>
			<p>If the request lacks a Host header, or has more than one Host header, return status 400 (Bad Request).</p>

			<h2>Compute effective request URI</h2>
			<p>Two lines are used to form the effective Request URI: the request-line (the first line in the request), and the Host header.</p>
			<p>HTTP allows requests with an absolute-form URI in the request-line, however this is not supported by very many servers, and is typically only used for requests to proxies.</p>
			<p>Most requests will be made with the origin-form:</p>
			<pre type="abnf" w:space="indent">
				request-target = origin-form
					/ absolute-form
					/ authority-form
					/ asterisk-form
				origin-form    = absolute-path [ "?" query ]
			</pre>
			<p>Servers must support all these forms, and can be parsed as follows:</p>
			<ol>
				<li>If the first character is the slash <code>/</code>, parse as origin-form.</li>
				<li>If the string contains a slash (not as the first character), parse as absolute-form.</li>
				<li>If the string is the single character asterisk <code>*</code>, parse as asterisk-form.</li>
				<li>Attempt to parse as authority-form.</li>
				<li>Otherwise, emit an error.</li>
			</ol>
			<p>For example:</p>
			<pre type="message/http" w:space="indent">
				GET /where?q=now HTTP/1.1
				Host: www.example.org
			</pre>
			<h4>From origin-form</h4>
			<p>To reconstruct from origin-form, three pieces of data are required: the scheme, the authority, and the path.</p>
			<p>The path must be configured or detected based on configuration. Ideally HTTP requests would always come in from <code>http:</code>. But this is not necessarially the case. First, it is technically possible for an HTTP server to respond to requests for any URI, for example a uuid. Second, HTTP is currently defined over two URI schemes, <code>http:</code> and <code>https:</code>, the latter of which is defined to be transported over TLS.</p>
			<p>The server must be configured to specify which schemes it is reachable by, and how to detect which scheme it was reached over. This is typically straightforward.</p>
			<p>The host is provided in the Host header. HTTP/1.0 does not require the Host header, in which case the server may either opt to detect the Host, or return an error.</p>
			<p>After validating, can be constructed from the template <code>{scheme}:{slash}{authority}{path}</code>, where:</p>
			<dl class="inline">
				<dt>{scheme}</dt><dd>the detected scheme</dd>
				<!--
					RFC7230 section 5.5 says the scheme and authority are concatenated with `://`,
					but according to section 5.4 if the URI has no authority component (and thus no `//`),
					the Host header is blank.
				-->
				<dt>{slash}</dt><dd>two slashes <code>//</code> if <code>authority</code> is non-empty, or an empty string otherwise</dd>
				<dt>{authority}</dt><dd>value from the <code>Host</code> header</dd>
				<dt>{path}</dt><dd>value from the request-URI</dd>
			</dl>
			<!-- TODO: reference TLS -->

			<h4>From absolute-form</h4>
			<p>The request-URI is what is found on the request-line.</p>
			<p>Verify the syntax is a valid URI, and return 400 (Client Error) if not.</p>
			<p>Verify the host and port (if any) components match the Host header, and return 400 (Client Error) if not.</p>

			<h4>Other forms</h4>
			<p>The other forms are special cases.</p>
			<p>If the asterisk-form is used with a method besides OPTIONS, emit 405 (Method Not Allowed).</p>
			<p>If the authority-form is used with a method besides CONNECT, emit 405 (Method Not Allowed).</p>
			<p>If there's no need to implement these, return 501 (Not Implemented).</p>

			<h2>Message Forwarding</h2>
			<p>If the server is forwarding the message to another node instead of handling it as an origin, it must implement the <code>Via</code> and <code>Max-Forwards</code> headers.</p>
			<p>Recall that connection headers (described above) cannot be forwarded since they convey information about the particular connection between nodes.</p>

			<h3>Via header</h3>
			<!-- Implements RFC7230 5.7.1. Via -->
			<p>The <code>Via</code> header specifies which intermediate nodes also processed the request, and will process the response. The server may use this for logging, debugging, or other informational purposes.</p>
			<p>If this message is going to be forwarded to another server, then append the current server information to the <code>Via</code> header.</p>

			<h3>Forwarded header</h3>
			<!-- Implements RFC7239 -->
			<p>The <code>Forwarded</code> header specifies which intermediate nodes also processed the request and associated information about the hop. The server may use this for logging, debugging, or other informational purposes.</p>
			<p>This varies from the "Via" header in that the Forwarded header is extensible, and can contain information such as the client IP address, which would otherwise be lost by a proxy or gateway.</p>
			<p>If this message is going to be forwarded to another server, then append the current server information to the <code>Forwarded</code> header.</p>

			<h3>Max-Forwards header</h3>
			<!-- Implements RFC7231 5.1.2. Max-Forwards -->
			<p>For nodes that would normally forward the request, the <code>Max-Forwards</code> header indicates if the node may forward the request. If the received value is <code>0</code>, then the node cannot forward the message, but must act as the target recipient; otherwise it must forward the message after deincrementing the value.</p>
			<p>Origin servers may generally ignore this header.</p>

			<h2>Handle Upgrade</h2>
			<!-- Implements RFC7230 6.7. Upgrade -->
			<p>The <code>Upgrade</code> request header asks the server to transition the protocol from HTTP/1.1 to some other protocol. Multiple protocols may be specified, which the server may choose from. The request is usually sent as a GET request.</p>
			<p>If the server intends to honor the request, then respond with 101 (Switching Protocols), a <code>Connection: upgrade</code> header, and an Upgrade header specifying the protocol. The server may ignore the header if it's content with the protocol as it is.</p>
			<aside><p>Primary differences from using CONNECT is that CONNECT is hop-by-hop, and as a method, cannot be ignored.</p></aside>

			<h2>Read request body</h2>
			<p>The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field.</p>

			<h3>Content-Type</h3>
			<p>The <code>Content-Type</code> header determines which media type will be used to decode the entity-body.</p>
			<p>Generally for every media type, there is a single specification that specifies how to parse and use the document.</p>

			<h3>Content-Language</h3>
			<p>HTTP allows the sender to identify the primary language of the entity body (request body or response body) using the <code>Content-Language</code> header.</p>

			<h2>Handle 100-continue</h2>
			<p>If the client set the <code>100-continue</code> flag, that means the client has paused uploading the request-body so it can first read any errors from the server, that the server might want to emit in response to the request headers.</p>
			<p>Since at this point all the headers look acceptable, emit a 100 (Continue) response, an intermediate response that will be replaced with the actual status code later on.</p>
			<p>Alternatively, if the client did not ask for 100-continue and there's a serious problem with accepting a large upload, the server can close the entire TCP connection.</p>

			<h2>Read payload</h2>
			<p>If nothing looks wrong with the request metadata, the server can begin accepting the payload body.</p>
			<ol>
				<li>If the first transfer coding to decode is "chunked", then read the chunked stream until it indicates the request-body is EOF.</li>
				<li>Otherwise if there is a Content-Length header, read that many bytes, then the request ends.</li>
			</ol>

			<h2>Decode transfer-codings</h2>
			<p>A <i>transfer coding</i> is a transform applied to the requested resource for transporting the representation over the network, usually to compress the representation, and to indicate when the body has ended.</p>
			<p>HTTP servers should (must?) support the following transfer-codings:</p>
			<ul>
				<li>chunked</li>
				<li>compress</li>
				<li>deflate</li>
				<li>gzip</li>
			</ul>
			<p></p>

			<h3>Transfer-Encoding: chunked</h3>
			<!-- Implements RFC7230 3.3.1. Transfer-Encoding -->
			<!-- Implements RFC7230 4.3. TE -->
			<!-- Implements RFC7230 4.4. Trailer -->
			<p>The <code>chunked</code> Transfer-Encoding is used to specify more detailed information about the status of the transfer, especially indicating when the transfer has ended.</p>

			<h2>Decode content-encoding</h2>
			<p>The values for <code>Content-Encoding</code> are:</p>
			<ul>
				<li>identity</li>
				<li>compress</li>
				<li>deflate</li>
				<li>gzip</li>
			</ul>

			<h3>chunked transfer-coding</h3>
			<p>The "chunked" transfer coding is capable of indicating when the request-body terminates, can be used to append headers to the end of the request, and metadata (for example, checksums). See the page on chunked coding for further information.</p>

			<h2>Write response headers</h2>
			<h3>HTTP-version</h3>
			<p>The server must reply with an HTTP version to which both the server and client are conformant. If the server is responding to a client in an HTTP version it doesn't understand, send the latest version the server understands in the response-line (e.g. <code>HTTP/1.1</code>).</p>

			<h3>Date</h3>
			<!-- Implements RFC7231 7.1.1 -->
			<p>The <code>Date</code> header is required for responses, unless the server doesn't have an accurate time to send. (Clients may also send this header, but it's optional for them.)</p>
			<p>For implementation, see <a href="headers/Date.html">HTTP Date header</a>.</p>

			<h3>Connection</h3>
			<p>If the server is going to close the connection at the end of the response, it must send the <code>Connection: close</code> to the client.</p>

			<h2>Write response body</h2>
			<h3>Compute length</h3>
			<!-- Implement RFC7230 3.3.2. Content-Length -->
			<p>If the server knows the length of the response, it can send the <code>Content-Length</code> header (however this precludes sending a Transfer-Encoding).</p>
			<p>A server MUST NOT send Content-Length with a 1xx status, a (204 No Content) status, or in response to a CONNECT request.</p>

			<h2>Clean up connection</h2>
			<h3>Handle Connection: close</h3>
			<!-- Implements RFC7230 6.6. Tear-down -->
			<p>If the client specified the <code>close</code> token in the <code>Connection</code> header, or if the connection is HTTP/1.0, the server must close the TCP channel here (even if the client sent additional requests).</p>
			<p>Recall that the server sends <code>Connection: close</code> to the client before it does this.</p>
			<aside><p>This is handled by Node.js.</p></aside>

			<h2>Overview table</h2>
			<h3>Referenced specifications</h3>
			<ul class="inline">
				<li><a href="https://httpwg.org/specs/rfc7230.html">RFC 7230: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a></li>
				<li><a href="https://httpwg.org/specs/rfc7231.html">RFC 7231: Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a></li>
				<li><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">IANA: Service Name and Transport Protocol Port Number Registry</a></li>
				<li><a href="https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml">IANA: Hypertext Transfer Protocol (HTTP) Status Code Registry</a></li>
				<li><a href="https://www.iana.org/assignments/http-methods/http-methods.xhtml">IANA: Hypertext Transfer Protocol (HTTP) Method Registry</a></li>
				<li><a href="https://www.iana.org/assignments/message-headers/message-headers.xhtml">IANA: Message Headers</a></li>
			</ul>
		</main>
	</body>
</html>
